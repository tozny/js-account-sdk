/*!
 * Tozny e3db
 *
 * LICENSE
 *
 * Tozny dual licenses this product. For commercial use, please contact
 * info@tozny.com. For non-commercial use, the contents of this file are
 * subject to the TOZNY NON-COMMERCIAL LICENSE (the "License") which
 * permits use of the software only by government agencies, schools,
 * universities, non-profit organizations or individuals on projects that
 * do not receive external funding other than government research grants
 * and contracts.  Any other use requires a commercial license. You may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at https://tozny.com/legal/non-commercial-license.
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
 * License for the specific language governing rights and limitations under
 * the License. Portions of the software are Copyright (c) TOZNY LLC, 2018-19.
 * All rights reserved.
 *
 * @copyright Copyright (c) 2018-19 Tozny, LLC (https://tozny.com)
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkCrypto = checkCrypto;
exports.checkConfig = checkConfig;
exports.btoa = btoa;
exports.checkStatus = checkStatus;
exports.validateResponseAsJSON = validateResponseAsJSON;
exports.urlEncodeData = urlEncodeData;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _crypto = _interopRequireDefault(require("../crypto"));

var _config = _interopRequireDefault(require("../storage/config"));

/**
 * Ensures a crypto instance is actually a crypto instance, throwing if it is not.
 * @param {Crypto} c The crypto instance to check
 */
function checkCrypto(c) {
  if (!(c instanceof _crypto["default"])) {
    throw new Error('Must pass a valid Crypto object');
  }
}
/**
 * Ensures a config instance is actually a config instance, throwing if it is not.
 * @param {Config} c The config instance to check
 */


function checkConfig(c) {
  if (!(c instanceof _config["default"])) {
    throw new Error('Must pass a valid Config object');
  }
}
/**
 * Fallback polyfill to allow for HTTP Basic authentication from either Node
 * or browser-based JavaScript.
 *
 * @param {string} str String to encode as Base64
 */


function btoa(str) {
  var buf = Buffer.from(str, 'utf8');
  return buf.toString('base64');
}
/**
 * Check the return status of a fetch request and throw an error if one occurred
 *
 * @param {Response} response
 *
 * @returns {Promise}
 */


function checkStatus(_x) {
  return _checkStatus.apply(this, arguments);
}
/**
 * Check the return status of a fetch and then parse return the body parsed as JSON.
 *
 * Throws an error if one has occurred in the fetch or the parse.
 *
 * @param {Response} response the fetch response object to check and parse
 *
 * @returns {Promise<Object>} A promise resolving to the JSON object contained in the response.
 */


function _checkStatus() {
  _checkStatus = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee(response) {
    var error;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!(response.status >= 200 && response.status < 300)) {
              _context.next = 2;
              break;
            }

            return _context.abrupt("return", Promise.resolve(response));

          case 2:
            error = new Error(response.statusText);
            error.response = response;
            throw error;

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _checkStatus.apply(this, arguments);
}

function validateResponseAsJSON(_x2) {
  return _validateResponseAsJSON.apply(this, arguments);
}
/**
 * URL encode an object for use as in an x-www-form-urlencoded body
 *
 * @param {Object} data The date to encode as form data
 *
 * @returns {string} The data as a URL encoded string for use in the body
 */


function _validateResponseAsJSON() {
  _validateResponseAsJSON = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee2(response) {
    var json;
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return checkStatus(response);

          case 2:
            _context2.next = 4;
            return response.json();

          case 4:
            json = _context2.sent;
            return _context2.abrupt("return", json);

          case 6:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _validateResponseAsJSON.apply(this, arguments);
}

function urlEncodeData(element, key) {
  var processed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  if ((0, _typeof2["default"])(element) === 'object') {
    for (var i in element) {
      if (element.hasOwnProperty(i)) {
        urlEncodeData(element[i], key ? "".concat(key, "[").concat(i, "]") : i, processed);
      }
    }
  } else {
    processed.push("".concat(key, "=").concat(encodeURIComponent(element)));
  }

  return processed.join('&');
}
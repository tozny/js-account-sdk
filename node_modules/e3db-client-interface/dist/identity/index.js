/*!
 * Tozny e3db
 *
 * LICENSE
 *
 * Tozny dual licenses this product. For commercial use, please contact
 * info@tozny.com. For non-commercial use, the contents of this file are
 * subject to the TOZNY NON-COMMERCIAL LICENSE (the "License") which
 * permits use of the software only by government agencies, schools,
 * universities, non-profit organizations or individuals on projects that
 * do not receive external funding other than government research grants
 * and contracts.  Any other use requires a commercial license. You may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at https://tozny.com/legal/non-commercial-license.
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
 * License for the specific language governing rights and limitations under
 * the License. Portions of the software are Copyright (c) TOZNY LLC, 2018-19.
 * All rights reserved.
 *
 * @copyright Copyright (c) 2018-19 Tozny, LLC (https://tozny.com)
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _client = _interopRequireDefault(require("./client"));

var _config = _interopRequireDefault(require("./config"));

require("isomorphic-fetch");

var _utils = require("../utils");

var _cryptoConsumer = _interopRequireDefault(require("../utils/cryptoConsumer"));

var _storage = require("../storage");

var _types = require("../types");

var _constants = require("../utils/constants");

function deriveNoteCreds(_x, _x2, _x3) {
  return _deriveNoteCreds.apply(this, arguments);
}

function _deriveNoteCreds() {
  _deriveNoteCreds = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee3(id, username, password) {
    var noteID, cryptoKeyPair, signingKeyPair;
    return _regenerator["default"].wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return id.crypto.genericHash(username + id.config.realmId);

          case 2:
            noteID = _context3.sent;
            _context3.next = 5;
            return id.crypto.deriveCryptoKey(password, id.config.realmId + id.config.realmName, _constants.IDENTITY_DERIVATION_ROUNDS);

          case 5:
            cryptoKeyPair = _context3.sent;
            _context3.next = 8;
            return id.crypto.deriveSigningKey(password, cryptoKeyPair.publicKey + cryptoKeyPair.privateKey, _constants.IDENTITY_DERIVATION_ROUNDS);

          case 8:
            signingKeyPair = _context3.sent;
            return _context3.abrupt("return", {
              noteID: noteID,
              cryptoKeyPair: cryptoKeyPair,
              signingKeyPair: signingKeyPair
            });

          case 10:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _deriveNoteCreds.apply(this, arguments);
}

function createClient(id, userId, storageConfig) {
  var idConfig = id.config.clone({
    userId: userId
  });
  var storageClient = new id.StorageClient(storageConfig);
  return new _client["default"](idConfig, storageClient, id.crypto);
}

var Identity =
/*#__PURE__*/
function (_CryptoConsumer) {
  (0, _inherits2["default"])(Identity, _CryptoConsumer);
  (0, _createClass2["default"])(Identity, null, [{
    key: "isExtension",
    value: function isExtension(identity) {
      return identity.prototype instanceof Identity;
    }
  }, {
    key: "Client",
    get: function get() {
      return _client["default"];
    }
  }, {
    key: "Config",
    get: function get() {
      return _config["default"];
    }
    /**
     * Abstract getter for a storage Client constructor function.
     *
     * When implementing this class, this getter must be overloaded. When called it
     * should offer up a storage Client constructor function. Identity constructs
     * storage clients as part of creating Identity clients.
     *
     * An additional instance level getter is also provided which allows fetching
     * the storage client constructor in both static _and_ instance method
     * contexts as `this.StorageClient`.
     *
     * @returns {Client} The storage Client constructor.
     */

  }, {
    key: "StorageClient",
    get: function get() {
      throw new Error('Implementing classes must overloaded the StorageClient method to provide a valid storage Client constructor.');
    }
  }]);

  function Identity(config) {
    var _this;

    (0, _classCallCheck2["default"])(this, Identity);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(Identity).call(this));
    _this.config = config;
    return _this;
  }
  /**
   * Allows `this.StorageClient` syntax in instance methods.
   *
   * Gets the static StorageClient constructor available in the static class. By
   * returning it as a getter `this.StorageClient` syntax is support in
   * instance methods.
   *
   * @returns {Client} The storage Client constructor.
   */


  (0, _createClass2["default"])(Identity, [{
    key: "register",
    value: function () {
      var _register = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee(username, password, token) {
        var cryptoKeys, signingKeys, payload, request, json, idClient, _ref, noteID, cryptoKeyPair, signingKeyPair;

        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.StorageClient.generateKeypair();

              case 2:
                cryptoKeys = _context.sent;
                _context.next = 5;
                return this.StorageClient.generateSigningKeypair();

              case 5:
                signingKeys = _context.sent;

                /* eslint-disable camelcase */
                payload = {
                  realm_registration_token: token,
                  realm_id: this.config.realmId,
                  identity: {
                    realm_id: this.config.realmId,
                    name: username,
                    public_key: new _types.PublicKey(cryptoKeys.publicKey),
                    signing_key: new _types.SigningKey(signingKeys.publicKey)
                  }
                  /* eslint-enable */

                };
                _context.next = 9;
                return fetch(this.config.apiUrl + '/v1/identity/register', {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify(payload)
                });

              case 9:
                request = _context.sent;
                _context.next = 12;
                return (0, _utils.validateResponseAsJSON)(request);

              case 12:
                json = _context.sent;
                idClient = createClient(this, json.identity.id, new _storage.Config(json.identity.tozny_id, json.identity.api_key_id, json.identity.api_secret_key, cryptoKeys.publicKey, cryptoKeys.privateKey, this.config.apiUrl, signingKeys.publicKey, signingKeys.privateKey)); // Login note

                _context.next = 16;
                return deriveNoteCreds(this, username, password);

              case 16:
                _ref = _context.sent;
                noteID = _ref.noteID;
                cryptoKeyPair = _ref.cryptoKeyPair;
                signingKeyPair = _ref.signingKeyPair;
                _context.next = 22;
                return idClient.storageClient.writeNote(idClient.serialize(), cryptoKeyPair.publicKey, signingKeyPair.publicKey, {
                  id_string: noteID,
                  max_views: -1,
                  expires: false
                });

              case 22:
                return _context.abrupt("return", idClient);

              case 23:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function register(_x4, _x5, _x6) {
        return _register.apply(this, arguments);
      }

      return register;
    }()
  }, {
    key: "login",
    value: function () {
      var _login = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee2(username, password) {
        var _ref2, noteID, cryptoKeyPair, signingKeyPair, storedCreds, idConfig;

        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return deriveNoteCreds(this, username, password);

              case 2:
                _ref2 = _context2.sent;
                noteID = _ref2.noteID;
                cryptoKeyPair = _ref2.cryptoKeyPair;
                signingKeyPair = _ref2.signingKeyPair;
                _context2.next = 8;
                return this.StorageClient.readNoteByName(noteID, cryptoKeyPair, signingKeyPair, this.config.apiUrl);

              case 8:
                storedCreds = _context2.sent;
                idConfig = _config["default"].fromObject(storedCreds.data.config);
                /* eslint-disable-next-line no-warning-comments */
                // TODO: Validate creds match this realm before instantiating

                return _context2.abrupt("return", createClient(this, idConfig.userId, _storage.Config.fromObject(storedCreds.data.storageConfig)));

              case 11:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function login(_x7, _x8) {
        return _login.apply(this, arguments);
      }

      return login;
    }()
  }, {
    key: "StorageClient",
    get: function get() {
      // Use this.constructor to ensure we referencing the implementing class, not an interface class.
      return this.constructor.StorageClient;
    }
  }]);
  return Identity;
}(_cryptoConsumer["default"]);

exports["default"] = Identity;
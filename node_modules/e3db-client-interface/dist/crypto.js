/*!
 * Tozny e3db
 *
 * LICENSE
 *
 * Tozny dual licenses this product. For commercial use, please contact
 * info@tozny.com. For non-commercial use, the contents of this file are
 * subject to the TOZNY NON-COMMERCIAL LICENSE (the "License") which
 * permits use of the software only by government agencies, schools,
 * universities, non-profit organizations or individuals on projects that
 * do not receive external funding other than government research grants
 * and contracts.  Any other use requires a commercial license. You may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at https://tozny.com/legal/non-commercial-license.
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
 * License for the specific language governing rights and limitations under
 * the License. Portions of the software are Copyright (c) TOZNY LLC, 2018-19.
 * All rights reserved.
 *
 * @copyright Copyright (c) 2018-19 Tozny, LLC (https://tozny.com)
 */
'use strict';
/* eslint-disable no-unused-vars */

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var Crypto =
/*#__PURE__*/
function () {
  (0, _createClass2["default"])(Crypto, null, [{
    key: "isExtension",
    value: function isExtension(crypto) {
      return crypto.prototype instanceof Crypto;
    }
  }, {
    key: "__notImplemented",
    value: function __notImplemented(name) {
      throw new Error("The method ".concat(name, " must be implemented in a subclass."));
    }
  }, {
    key: "instance",
    get: function get() {
      if ((0, _typeof2["default"])(this._instance) !== 'object' || !(this._instance instanceof Crypto)) {
        this._instance = new this();
      }

      return this._instance;
    }
  }]);

  function Crypto() {
    (0, _classCallCheck2["default"])(this, Crypto);

    if (this.constructor === Crypto) {
      throw new Error('The Crypto class must be extended with a specific (Type)Crypto class before use.');
    }
  }
  /**
   * Mode returns a string denoting which crypto library this implementation uses under the hood.
   */


  (0, _createClass2["default"])(Crypto, [{
    key: "mode",
    value: function mode() {
      Crypto.__notImplemented('mode');
    }
    /**
     * Symmetrically encrypt and serialize a string with the given key
     *
     * @param {string} plain The plain text string to encrypt
     * @param {string} key   Base64 encoded key used to encrypt the string.
     *
     * @return {Promise<string>} The encrypted string base64URL encoded with a serialized nonce.
     */

  }, {
    key: "encryptString",
    value: function () {
      var _encryptString = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee(plain, key) {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                Crypto.__notImplemented('encryptString');

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function encryptString(_x, _x2) {
        return _encryptString.apply(this, arguments);
      }

      return encryptString;
    }()
    /**
     * Decrypt a symmetrically encrypted string
     *
     * @param {string} encrypted Base64 encoded string in nonce:cipherText format.
     * @param {string} key       Base64 encoded key used to encrypt the string.
     *
     * @return {Promise<string>} The decrypted UTF-8 string.
     */

  }, {
    key: "decryptString",
    value: function () {
      var _decryptString = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee2(encrypted, key) {
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                Crypto.__notImplemented('decryptString');

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function decryptString(_x3, _x4) {
        return _decryptString.apply(this, arguments);
      }

      return decryptString;
    }()
    /**
     * EncryptField encrypts a string of text into a standard Tozny quat format using the provided access key.
     */

  }, {
    key: "encryptField",
    value: function encryptField(field, accessKey) {
      Crypto.__notImplemented('encryptField');
    }
    /**
     * DecryptField decrypts a standard Tozny quad using the provided access key.
     */

  }, {
    key: "decryptField",
    value: function decryptField(encryptedField, accessKey) {
      Crypto.__notImplemented('decryptField');
    }
    /**
     * EncryptNote implements method to encrypt the data within a note given the note and accessKey.
     */

  }, {
    key: "encryptNote",
    value: function encryptNote(note, accessKey) {
      Crypto.__notImplemented('encryptNote');
    }
    /**
     * DecryptNote implements method to decrypt the data within a note given the note and accessKey.
     */

  }, {
    key: "decryptNote",
    value: function decryptNote(encrypted, accessKey) {
      Crypto.__notImplemented('decryptNote');
    }
    /**
     * DecryptNoteEak is an internal method to decrypt a note's encrypted access key,
     * so that the note can be decrypted.
     */

  }, {
    key: "decryptNoteEak",
    value: function decryptNoteEak(readerKey, encryptedAk, writerKey) {
      Crypto.__notImplemented('decryptEak');
    }
  }, {
    key: "decryptEak",
    value: function decryptEak(readerKey, encryptedEak) {
      Crypto.__notImplemented('decryptEak');
    }
  }, {
    key: "encryptAk",
    value: function encryptAk(writerKey, ak, readerKey) {
      Crypto.__notImplemented('encryptAk');
    }
  }, {
    key: "decryptRecord",
    value: function decryptRecord(encrypted, accessKey) {
      Crypto.__notImplemented('decryptRecord');
    }
  }, {
    key: "encryptRecord",
    value: function encryptRecord(record, accessKey) {
      Crypto.__notImplemented('encryptRecord');
    }
  }, {
    key: "verifyDocumentSignature",
    value: function verifyDocumentSignature(document, signature, verifyingKey) {
      Crypto.__notImplemented('verifyDocumentSignature');
    }
  }, {
    key: "signDocument",
    value: function signDocument(document, signingKey) {
      Crypto.__notImplemented('signDocument');
    }
  }, {
    key: "b64encode",
    value: function b64encode(raw) {
      Crypto.__notImplemented('b64encode');
    }
  }, {
    key: "b64decode",
    value: function b64decode(encoded) {
      Crypto.__notImplemented('b64decode');
    }
  }, {
    key: "randomKey",
    value: function randomKey() {
      Crypto.__notImplemented('randomKey');
    }
  }, {
    key: "randomNonce",
    value: function randomNonce() {
      Crypto.__notImplemented('randomNonce');
    }
  }, {
    key: "randomBytes",
    value: function randomBytes(length) {
      Crypto.__notImplemented('randomBytes');
    }
  }, {
    key: "deriveKey",
    value: function deriveKey(password, salt, length, iterations) {
      Crypto.__notImplemented('deriveKey');
    }
  }, {
    key: "deriveSigningKey",
    value: function deriveSigningKey(password, salt, iterations) {
      Crypto.__notImplemented('deriveSigningKey');
    }
  }, {
    key: "deriveCryptoKey",
    value: function deriveCryptoKey(password, salt, iterations) {
      Crypto.__notImplemented('deriveCryptoKey');
    }
  }, {
    key: "deriveSymmetricKey",
    value: function deriveSymmetricKey(password, salt) {
      Crypto.__notImplemented('deriveSymmetricKey');
    }
  }, {
    key: "generateKeypair",
    value: function generateKeypair() {
      Crypto.__notImplemented('generateKeypair');
    }
  }, {
    key: "generateSigningKeypair",
    value: function generateSigningKeypair() {
      Crypto.__notImplemented('generateSigningKeypair');
    }
  }, {
    key: "encryptLargeFile",
    value: function encryptLargeFile(fileObj, ak) {
      Crypto.__notImplemented('encryptLargeFile');
    }
  }, {
    key: "decryptFile",
    value: function decryptFile(destinationFilename, ak, encryptedFile) {
      Crypto.__notImplemented('decryptFile');
    }
    /*
     * Sign a message and return the signature separate from the message.
     */

  }, {
    key: "signDetached",
    value: function signDetached(stringToSign, privateKey) {
      Crypto.__notImplemented('signDetached');
    }
    /*
     * Generate a secure hash with BLAKE2b.
     */

  }, {
    key: "genericHash",
    value: function genericHash(message) {
      Crypto.__notImplemented('genericHash');
    }
  }]);
  return Crypto;
}();

module.exports = Crypto;
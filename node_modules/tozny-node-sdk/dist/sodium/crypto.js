/*!
 * Tozny e3db
 *
 * LICENSE
 *
 * Tozny dual licenses this product. For commercial use, please contact
 * info@tozny.com. For non-commercial use, the contents of this file are
 * subject to the TOZNY NON-COMMERCIAL LICENSE (the "License") which
 * permits use of the software only by government agencies, schools,
 * universities, non-profit organizations or individuals on projects that
 * do not receive external funding other than government research grants
 * and contracts.  Any other use requires a commercial license. You may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at https://tozny.com/legal/non-commercial-license.
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
 * License for the specific language governing rights and limitations under
 * the License. Portions of the software are Copyright (c) TOZNY LLC, 2017.
 * All rights reserved.
 *
 * @copyright Copyright (c) 2017 Tozny, LLC (https://tozny.com)
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _crypto = _interopRequireDefault(require("crypto"));

var _fs = _interopRequireDefault(require("fs"));

var _awaitifyStream = _interopRequireDefault(require("awaitify-stream"));

var _libsodiumWrappers = _interopRequireDefault(require("libsodium-wrappers"));

var _e3dbClientInterface = require("e3db-client-interface");

var _base64url = _interopRequireDefault(require("base64url"));

var _jsMd = _interopRequireDefault(require("js-md5"));

var _constants = require("../utils/constants");

var Crypto =
/*#__PURE__*/
function (_CryptoBase) {
  (0, _inherits2["default"])(Crypto, _CryptoBase);

  function Crypto() {
    (0, _classCallCheck2["default"])(this, Crypto);
    return (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(Crypto).apply(this, arguments));
  }

  (0, _createClass2["default"])(Crypto, [{
    key: "mode",

    /**
     * Mode returns a string denoting which crypto library this implementation uses under the hood.
     */
    value: function mode() {
      return 'Sodium';
    }
    /**
     * Symmetrically encrypt and serialize a string with the given key
     *
     * @param {string} plain The plain text string to encrypt
     * @param {string} key   Base64 encoded key used to encrypt the string.
     *
     * @return {Promise<string>} The encrypted string base64URL encoded with a serialized nonce.
     */

  }, {
    key: "encryptString",
    value: function () {
      var _encryptString = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee2(plain, key) {
        var _this = this;

        var rawKey, nonce, encrypted;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return _libsodiumWrappers["default"].ready;

              case 2:
                _context2.next = 4;
                return this.b64decode(key);

              case 4:
                rawKey = _context2.sent;
                _context2.next = 7;
                return this.randomNonce();

              case 7:
                nonce = _context2.sent;
                encrypted = _libsodiumWrappers["default"].crypto_secretbox_easy(plain, nonce, rawKey);
                return _context2.abrupt("return", Promise.all([nonce, encrypted].map(
                /*#__PURE__*/
                function () {
                  var _ref = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee(x) {
                    return _regenerator["default"].wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            return _context.abrupt("return", _this.b64encode(x));

                          case 1:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee);
                  }));

                  return function (_x3) {
                    return _ref.apply(this, arguments);
                  };
                }())).then(function (x) {
                  return x.join(':');
                }));

              case 10:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function encryptString(_x, _x2) {
        return _encryptString.apply(this, arguments);
      }

      return encryptString;
    }()
    /**
     * Decrypt a symmetrically encrypted string
     *
     * @param {string} encrypted Base64 encoded string in nonce:cipherText format.
     * @param {string} key       Base64 encoded key used to encrypt the string.
     *
     * @return {Promise<string>} The decrypted UTF-8 string.
     */

  }, {
    key: "decryptString",
    value: function () {
      var _decryptString = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee4(encrypted, key) {
        var _this2 = this;

        var rawKey, components, _ref2, _ref3, nonce, cipher, decrypted;

        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return _libsodiumWrappers["default"].ready;

              case 2:
                _context4.next = 4;
                return this.b64decode(key);

              case 4:
                rawKey = _context4.sent;
                components = encrypted.split(':');
                _context4.next = 8;
                return Promise.all(components.map(
                /*#__PURE__*/
                function () {
                  var _ref4 = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee3(x) {
                    return _regenerator["default"].wrap(function _callee3$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            return _context3.abrupt("return", _this2.b64decode(x));

                          case 1:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    }, _callee3);
                  }));

                  return function (_x6) {
                    return _ref4.apply(this, arguments);
                  };
                }()));

              case 8:
                _ref2 = _context4.sent;
                _ref3 = (0, _slicedToArray2["default"])(_ref2, 2);
                nonce = _ref3[0];
                cipher = _ref3[1];
                decrypted = _libsodiumWrappers["default"].crypto_secretbox_open_easy(cipher, nonce, rawKey);
                return _context4.abrupt("return", Buffer.from(decrypted).toString('utf8'));

              case 14:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function decryptString(_x4, _x5) {
        return _decryptString.apply(this, arguments);
      }

      return decryptString;
    }()
    /**
     * Encrypt a string into the standard Tozny quad format using Libsodium's secretbox.
     *
     * @param {string} field The string of data to encrypt as a data field.
     * @param {Uint8Array} accessKey The access key bytes to encrypt the field with.
     *
     * @returns {Promise<String>} The Tozny dotted quad encrypted field.
     */

  }, {
    key: "encryptField",
    value: function () {
      var _encryptField = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee5(field, accessKey) {
        var dk, efN, ef, edkN, edk, encryptedField;
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.randomKey();

              case 2:
                dk = _context5.sent;
                _context5.next = 5;
                return this.randomNonce();

              case 5:
                efN = _context5.sent;
                ef = _libsodiumWrappers["default"].crypto_secretbox_easy(field, efN, dk);
                _context5.next = 9;
                return this.randomNonce();

              case 9:
                edkN = _context5.sent;
                edk = _libsodiumWrappers["default"].crypto_secretbox_easy(dk, edkN, accessKey);
                _context5.next = 13;
                return this.b64encode(edk);

              case 13:
                _context5.t0 = _context5.sent;
                _context5.next = 16;
                return this.b64encode(edkN);

              case 16:
                _context5.t1 = _context5.sent;
                _context5.next = 19;
                return this.b64encode(ef);

              case 19:
                _context5.t2 = _context5.sent;
                _context5.next = 22;
                return this.b64encode(efN);

              case 22:
                _context5.t3 = _context5.sent;
                encryptedField = [_context5.t0, _context5.t1, _context5.t2, _context5.t3].join('.');
                return _context5.abrupt("return", encryptedField);

              case 25:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function encryptField(_x7, _x8) {
        return _encryptField.apply(this, arguments);
      }

      return encryptField;
    }()
    /**
     * Decrypt a standard Tozny dotted quad using Libsodium's secretbox into a string.
     *
     * @param {string}     encryptedField A standard Tozny dotted quad string.
     * @param {Uint8Array} accessKey      The access key bytes to use as the decryption key.
     *
     * @return {Promise<string>} The decrypted data field as a UTF-8 string.
     */

  }, {
    key: "decryptField",
    value: function () {
      var _decryptField = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee7(encryptedField, accessKey) {
        var _this3 = this;

        var components, _ref5, _ref6, edk, edkN, ef, efN, dk, field;

        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                components = encryptedField.split('.');
                _context7.next = 3;
                return Promise.all(components.map(
                /*#__PURE__*/
                function () {
                  var _ref7 = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee6(x) {
                    return _regenerator["default"].wrap(function _callee6$(_context6) {
                      while (1) {
                        switch (_context6.prev = _context6.next) {
                          case 0:
                            return _context6.abrupt("return", _this3.b64decode(x));

                          case 1:
                          case "end":
                            return _context6.stop();
                        }
                      }
                    }, _callee6);
                  }));

                  return function (_x11) {
                    return _ref7.apply(this, arguments);
                  };
                }()));

              case 3:
                _ref5 = _context7.sent;
                _ref6 = (0, _slicedToArray2["default"])(_ref5, 4);
                edk = _ref6[0];
                edkN = _ref6[1];
                ef = _ref6[2];
                efN = _ref6[3];
                dk = _libsodiumWrappers["default"].crypto_secretbox_open_easy(edk, edkN, accessKey);
                field = _libsodiumWrappers["default"].crypto_secretbox_open_easy(ef, efN, dk);
                return _context7.abrupt("return", Buffer.from(field).toString('utf8'));

              case 12:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }));

      function decryptField(_x9, _x10) {
        return _decryptField.apply(this, arguments);
      }

      return decryptField;
    }()
    /**
     * Decrypt the access key provided for a specific reader so it can be used
     * to further decrypt a protected record.
     *
     * @param {string} readerKey   Base64url-encoded private key for the reader (current client)
     * @param {EAKInfo} encryptedAk Encrypted access key
     *
     * @return {Promise<string>} Raw binary string of the access key
     */

  }, {
    key: "decryptEak",
    value: function () {
      var _decryptEak = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee9(readerKey, encryptedAk) {
        var _this4 = this;

        var encodedEak, publicKey, privateKey, _ref8, _ref9, eak, nonce;

        return _regenerator["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return _libsodiumWrappers["default"].ready;

              case 2:
                encodedEak = encryptedAk.eak;
                _context9.next = 5;
                return this.b64decode(encryptedAk.authorizerPublicKey.curve25519);

              case 5:
                publicKey = _context9.sent;
                _context9.next = 8;
                return this.b64decode(readerKey);

              case 8:
                privateKey = _context9.sent;
                _context9.next = 11;
                return Promise.all(encodedEak.split('.').map(
                /*#__PURE__*/
                function () {
                  var _ref10 = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee8(x) {
                    return _regenerator["default"].wrap(function _callee8$(_context8) {
                      while (1) {
                        switch (_context8.prev = _context8.next) {
                          case 0:
                            return _context8.abrupt("return", _this4.b64decode(x));

                          case 1:
                          case "end":
                            return _context8.stop();
                        }
                      }
                    }, _callee8);
                  }));

                  return function (_x14) {
                    return _ref10.apply(this, arguments);
                  };
                }()));

              case 11:
                _ref8 = _context9.sent;
                _ref9 = (0, _slicedToArray2["default"])(_ref8, 2);
                eak = _ref9[0];
                nonce = _ref9[1];
                return _context9.abrupt("return", _libsodiumWrappers["default"].crypto_box_open_easy(eak, nonce, publicKey, privateKey));

              case 16:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function decryptEak(_x12, _x13) {
        return _decryptEak.apply(this, arguments);
      }

      return decryptEak;
    }()
  }, {
    key: "decryptNoteEak",
    value: function () {
      var _decryptNoteEak = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee11(readerKey, encryptedAk, writerKey) {
        var _this5 = this;

        var encodedEak, publicKey, privateKey, _ref11, _ref12, eak, nonce;

        return _regenerator["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return _libsodiumWrappers["default"].ready;

              case 2:
                encodedEak = encryptedAk.eak;
                _context11.next = 5;
                return this.b64decode(writerKey);

              case 5:
                publicKey = _context11.sent;
                _context11.next = 8;
                return this.b64decode(readerKey);

              case 8:
                privateKey = _context11.sent;
                _context11.next = 11;
                return Promise.all(encodedEak.split('.').map(
                /*#__PURE__*/
                function () {
                  var _ref13 = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee10(x) {
                    return _regenerator["default"].wrap(function _callee10$(_context10) {
                      while (1) {
                        switch (_context10.prev = _context10.next) {
                          case 0:
                            return _context10.abrupt("return", _this5.b64decode(x));

                          case 1:
                          case "end":
                            return _context10.stop();
                        }
                      }
                    }, _callee10);
                  }));

                  return function (_x18) {
                    return _ref13.apply(this, arguments);
                  };
                }()));

              case 11:
                _ref11 = _context11.sent;
                _ref12 = (0, _slicedToArray2["default"])(_ref11, 2);
                eak = _ref12[0];
                nonce = _ref12[1];
                return _context11.abrupt("return", _libsodiumWrappers["default"].crypto_box_open_easy(eak, nonce, publicKey, privateKey));

              case 16:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function decryptNoteEak(_x15, _x16, _x17) {
        return _decryptNoteEak.apply(this, arguments);
      }

      return decryptNoteEak;
    }()
    /**
     * Encrypt an access key for a given reader.
     *
     * @param {string} writerKey Base64url-encoded private key of the writer
     * @param {string} ak        Raw binary string of the access key
     * @param {string} readerKey Base64url-encoded public key of the reader
     *
     * @return {Promise<string>} Encrypted and encoded access key.
     */

  }, {
    key: "encryptAk",
    value: function () {
      var _encryptAk = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee12(writerKey, ak, readerKey) {
        var publicKey, privateKey, nonce, eak;
        return _regenerator["default"].wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return _libsodiumWrappers["default"].ready;

              case 2:
                _context12.next = 4;
                return this.b64decode(readerKey);

              case 4:
                publicKey = _context12.sent;
                _context12.next = 7;
                return this.b64decode(writerKey);

              case 7:
                privateKey = _context12.sent;
                _context12.next = 10;
                return this.randomNonce();

              case 10:
                nonce = _context12.sent;
                eak = _libsodiumWrappers["default"].crypto_box_easy(ak, nonce, publicKey, privateKey);
                _context12.next = 14;
                return this.b64encode(eak);

              case 14:
                _context12.t0 = _context12.sent;
                _context12.t1 = _context12.t0 + '.';
                _context12.next = 18;
                return this.b64encode(nonce);

              case 18:
                _context12.t2 = _context12.sent;
                return _context12.abrupt("return", _context12.t1 + _context12.t2);

              case 20:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function encryptAk(_x19, _x20, _x21) {
        return _encryptAk.apply(this, arguments);
      }

      return encryptAk;
    }()
    /**
     * Create a clone of a given record, but decrypting each field in turn based on
     * the provided access key.
     *
     * @param {Record} encrypted Record to be unwrapped
     * @param {string} accessKey Access key to use for decrypting each data key.
     *
     * @return {Promise<Record>}
     */

  }, {
    key: "decryptRecord",
    value: function () {
      var _decryptRecord = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee13(encrypted, accessKey) {
        var meta, decrypted, key;
        return _regenerator["default"].wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return _libsodiumWrappers["default"].ready;

              case 2:
                // Clone the record meta
                meta = new _e3dbClientInterface.types.Meta(encrypted.meta.writerId, encrypted.meta.userId, encrypted.meta.type, encrypted.meta.plain);
                meta.recordId = encrypted.meta.recordId;
                meta.created = encrypted.meta.created;
                meta.lastModified = encrypted.meta.lastModified;
                meta.version = encrypted.meta.version;
                decrypted = new _e3dbClientInterface.types.Record(meta, {}, encrypted.signature); // Decrypt the record data

                _context13.t0 = _regenerator["default"].keys(encrypted.data);

              case 9:
                if ((_context13.t1 = _context13.t0()).done) {
                  _context13.next = 17;
                  break;
                }

                key = _context13.t1.value;

                if (!encrypted.data.hasOwnProperty(key)) {
                  _context13.next = 15;
                  break;
                }

                _context13.next = 14;
                return this.decryptField(encrypted.data[key], accessKey);

              case 14:
                decrypted.data[key] = _context13.sent;

              case 15:
                _context13.next = 9;
                break;

              case 17:
                return _context13.abrupt("return", decrypted);

              case 18:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function decryptRecord(_x22, _x23) {
        return _decryptRecord.apply(this, arguments);
      }

      return decryptRecord;
    }()
    /**
     * Create a clone of a plaintext record, encrypting each field in turn with a random
     * data key and protecting the data key with a set access key.
     *
     * @param {Record} record    Record to be encrypted.
     * @param {string} accessKey Access key to use for decrypting each data key.
     *
     * @return {Promise<Record>}
     */

  }, {
    key: "encryptRecord",
    value: function () {
      var _encryptRecord = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee14(record, accessKey) {
        var meta, encrypted, key;
        return _regenerator["default"].wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return _libsodiumWrappers["default"].ready;

              case 2:
                // Clone the record meta
                meta = new _e3dbClientInterface.types.Meta(record.meta.writerId, record.meta.userId, record.meta.type, record.meta.plain);
                encrypted = new _e3dbClientInterface.types.Record(meta, {}, record.signature); // Encrypt the record data

                _context14.t0 = _regenerator["default"].keys(record.data);

              case 5:
                if ((_context14.t1 = _context14.t0()).done) {
                  _context14.next = 13;
                  break;
                }

                key = _context14.t1.value;

                if (!record.data.hasOwnProperty(key)) {
                  _context14.next = 11;
                  break;
                }

                _context14.next = 10;
                return this.encryptField(record.data[key], accessKey);

              case 10:
                encrypted.data[key] = _context14.sent;

              case 11:
                _context14.next = 5;
                break;

              case 13:
                return _context14.abrupt("return", encrypted);

              case 14:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function encryptRecord(_x24, _x25) {
        return _encryptRecord.apply(this, arguments);
      }

      return encryptRecord;
    }()
    /**
     * Verify the signature on a given JSON document, given a specific public signing key.
     *
     * @param {Serializable} document     Document to be verified
     * @param {string}       signature    Base64URL-encoded signature
     * @param {string}       verifyingKey Base64URL-encoded signing key
     *
     * @returns {Promise<bool>}
     */

  }, {
    key: "verifyDocumentSignature",
    value: function () {
      var _verifyDocumentSignature = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee15(document, signature, verifyingKey) {
        var message, rawSignature, rawKey;
        return _regenerator["default"].wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                _context15.next = 2;
                return _libsodiumWrappers["default"].ready;

              case 2:
                message = document.stringify();
                _context15.next = 5;
                return this.b64decode(signature);

              case 5:
                rawSignature = _context15.sent;
                _context15.next = 8;
                return this.b64decode(verifyingKey);

              case 8:
                rawKey = _context15.sent;
                return _context15.abrupt("return", _libsodiumWrappers["default"].crypto_sign_verify_detached(rawSignature, message, rawKey));

              case 10:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function verifyDocumentSignature(_x26, _x27, _x28) {
        return _verifyDocumentSignature.apply(this, arguments);
      }

      return verifyDocumentSignature;
    }()
    /**
     * Sign a document and return the signature
     *
     * @param {Signable} document   Serializable object to be signed
     * @param {string}   signingKey Key to use to sign the document
     *
     * @returns {Promise<string>}
     */

  }, {
    key: "signDocument",
    value: function () {
      var _signDocument = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee16(document, signingKey) {
        var message, rawKey, signature;
        return _regenerator["default"].wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _context16.next = 2;
                return _libsodiumWrappers["default"].ready;

              case 2:
                message = document.stringify();
                _context16.next = 5;
                return this.b64decode(signingKey);

              case 5:
                rawKey = _context16.sent;
                signature = _libsodiumWrappers["default"].crypto_sign_detached(message, rawKey);
                return _context16.abrupt("return", this.b64encode(signature));

              case 8:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function signDocument(_x29, _x30) {
        return _signDocument.apply(this, arguments);
      }

      return signDocument;
    }()
    /**
     * Base64 encode a string in a URL safe manner with no padding
     *
     * @param {string} raw Raw data to be encoded
     *
     * @returns {string}
     */

  }, {
    key: "b64encode",
    value: function () {
      var _b64encode = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee17(raw) {
        return _regenerator["default"].wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                return _context17.abrupt("return", (0, _base64url["default"])(raw));

              case 1:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17);
      }));

      function b64encode(_x31) {
        return _b64encode.apply(this, arguments);
      }

      return b64encode;
    }()
    /**
     * Decode a Base64URL-encoded string
     *
     * @param {string} encoded Base64URL-encoded string
     *
     * @returns {string}
     */

  }, {
    key: "b64decode",
    value: function () {
      var _b64decode = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee18(encoded) {
        var b64Dec, u8, i;
        return _regenerator["default"].wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                b64Dec = _base64url["default"].toBuffer(encoded);
                u8 = new Uint8Array(b64Dec.length);

                for (i = 0; i < b64Dec.length; i++) {
                  u8[i] = b64Dec[i];
                }

                return _context18.abrupt("return", u8);

              case 4:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18);
      }));

      function b64decode(_x32) {
        return _b64decode.apply(this, arguments);
      }

      return b64decode;
    }()
    /**
     * Generate a random key for use with Libsodium's secretbox interface
     *
     * @returns {Uint8Array} An array of random bytes the default key length
     */

  }, {
    key: "randomKey",
    value: function () {
      var _randomKey = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee19() {
        return _regenerator["default"].wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                _context19.next = 2;
                return _libsodiumWrappers["default"].ready;

              case 2:
                return _context19.abrupt("return", _libsodiumWrappers["default"].crypto_secretbox_keygen());

              case 3:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19);
      }));

      function randomKey() {
        return _randomKey.apply(this, arguments);
      }

      return randomKey;
    }()
    /**
     * Generate a random nonce for use with Libsodium's secretbox interface
     *
     * @returns {Uint8Array} An array of random bytes the default nonce length
     */

  }, {
    key: "randomNonce",
    value: function () {
      var _randomNonce = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee20() {
        return _regenerator["default"].wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                return _context20.abrupt("return", this.randomBytes(_libsodiumWrappers["default"].crypto_secretbox_NONCEBYTES));

              case 1:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function randomNonce() {
        return _randomNonce.apply(this, arguments);
      }

      return randomNonce;
    }()
    /**
     * Generate random bytes `length` long.
     *
     * @param {number} length The number of random bytes to generate
     *
     * @returns {Uint8Array} An array of random bytes
     */

  }, {
    key: "randomBytes",
    value: function () {
      var _randomBytes = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee21(length) {
        return _regenerator["default"].wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                _context21.next = 2;
                return _libsodiumWrappers["default"].ready;

              case 2:
                return _context21.abrupt("return", _libsodiumWrappers["default"].randombytes_buf(length));

              case 3:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21);
      }));

      function randomBytes(_x33) {
        return _randomBytes.apply(this, arguments);
      }

      return randomBytes;
    }()
    /**
     * Use PBKDF2 to derive a key of a given length using a specified password
     * and salt.
     *
     * @param {string} password     User-specified password
     * @param {string} salt         User-specified salt (should be random)
     * @param {number} length       Length of the key to generate
     * @param {number} [iterations] Option number of hash iterations to create the seed.
     *
     * @returns {Promise<ArrayBuffer>}
     */

  }, {
    key: "deriveKey",
    value: function () {
      var _deriveKey = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee22(password, salt, length) {
        var iterations,
            _args22 = arguments;
        return _regenerator["default"].wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                iterations = _args22.length > 3 && _args22[3] !== undefined ? _args22[3] : _constants.DEFAULT_KDF_ITERATIONS;
                return _context22.abrupt("return", new Promise(function (resolve, reject) {
                  _crypto["default"].pbkdf2(password, salt, iterations, length, 'sha512', function (err, val) {
                    return err ? reject(err) : resolve(val);
                  });
                }));

              case 2:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22);
      }));

      function deriveKey(_x34, _x35, _x36) {
        return _deriveKey.apply(this, arguments);
      }

      return deriveKey;
    }()
    /**
     * Derive an Ed25519 keypair from a password and a random salt
     *
     * @param {string} password     User-specified password
     * @param {string} salt         User-specified salt (should be random)
     * @param {number} [iterations] Option number of hash iterations to create the seed.
     *
     * @returns {KeyPair} Object containing publicKey and privateKey fields
     */

  }, {
    key: "deriveSigningKey",
    value: function () {
      var _deriveSigningKey = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee23(password, salt) {
        var iterations,
            seed,
            keypair,
            _args23 = arguments;
        return _regenerator["default"].wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                iterations = _args23.length > 2 && _args23[2] !== undefined ? _args23[2] : _constants.DEFAULT_KDF_ITERATIONS;
                _context23.next = 3;
                return _libsodiumWrappers["default"].ready;

              case 3:
                _context23.next = 5;
                return this.deriveKey(password, salt, _libsodiumWrappers["default"].crypto_sign_SEEDBYTES, iterations);

              case 5:
                seed = _context23.sent;
                keypair = _libsodiumWrappers["default"].crypto_sign_seed_keypair(new Uint8Array(seed));
                _context23.t0 = _e3dbClientInterface.types.KeyPair;
                _context23.next = 10;
                return this.b64encode(keypair.publicKey);

              case 10:
                _context23.t1 = _context23.sent;
                _context23.next = 13;
                return this.b64encode(keypair.privateKey);

              case 13:
                _context23.t2 = _context23.sent;
                return _context23.abrupt("return", new _context23.t0(_context23.t1, _context23.t2));

              case 15:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function deriveSigningKey(_x37, _x38) {
        return _deriveSigningKey.apply(this, arguments);
      }

      return deriveSigningKey;
    }()
    /**
     * Derive a Curve25519 keypair from a password and a random salt
     *
     * @param {string} password     User-specified password
     * @param {string} salt         User-specified salt (should be random)
     * @param {number} [iterations] Option number of hash iterations to create the seed.
     *
     * @returns {KeyPair} Object containing publicKey and privateKey fields
     */

  }, {
    key: "deriveCryptoKey",
    value: function () {
      var _deriveCryptoKey = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee24(password, salt) {
        var iterations,
            seed,
            keypair,
            _args24 = arguments;
        return _regenerator["default"].wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                iterations = _args24.length > 2 && _args24[2] !== undefined ? _args24[2] : _constants.DEFAULT_KDF_ITERATIONS;
                _context24.next = 3;
                return _libsodiumWrappers["default"].ready;

              case 3:
                _context24.next = 5;
                return this.deriveKey(password, salt, _libsodiumWrappers["default"].crypto_sign_SEEDBYTES, iterations);

              case 5:
                seed = _context24.sent;
                keypair = _libsodiumWrappers["default"].crypto_box_seed_keypair(new Uint8Array(seed));
                _context24.t0 = _e3dbClientInterface.types.KeyPair;
                _context24.next = 10;
                return this.b64encode(keypair.publicKey);

              case 10:
                _context24.t1 = _context24.sent;
                _context24.next = 13;
                return this.b64encode(keypair.privateKey);

              case 13:
                _context24.t2 = _context24.sent;
                return _context24.abrupt("return", new _context24.t0(_context24.t1, _context24.t2));

              case 15:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function deriveCryptoKey(_x39, _x40) {
        return _deriveCryptoKey.apply(this, arguments);
      }

      return deriveCryptoKey;
    }()
    /**
     * Derive a symmetric encryption key from a password and a random salt
     *
     * @param {string} password User-specified password
     * @param {string} salt     User-specified salt (should be random)
     * @param {number} [iterations] Option number of hash iterations to create the seed.
     *
     * @returns {string} base64Url encoded string
     */

  }, {
    key: "deriveSymmetricKey",
    value: function () {
      var _deriveSymmetricKey = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee25(password, salt) {
        var iterations,
            buffer,
            b64String,
            _args25 = arguments;
        return _regenerator["default"].wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                iterations = _args25.length > 2 && _args25[2] !== undefined ? _args25[2] : _constants.DEFAULT_KDF_ITERATIONS;
                _context25.next = 3;
                return this.deriveKey(password, salt, _libsodiumWrappers["default"].crypto_secretbox_KEYBYTES, iterations);

              case 3:
                buffer = _context25.sent;
                _context25.next = 6;
                return this.b64encode(buffer);

              case 6:
                b64String = _context25.sent;
                return _context25.abrupt("return", b64String);

              case 8:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function deriveSymmetricKey(_x41, _x42) {
        return _deriveSymmetricKey.apply(this, arguments);
      }

      return deriveSymmetricKey;
    }()
    /**
     * Dynamically generate a Curve25519 keypair for use with registration and cryptographic operations
     *
     * @returns {KeyPair} Base64URL-encoded representation of the new keypair
     */

  }, {
    key: "generateKeypair",
    value: function () {
      var _generateKeypair = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee26() {
        var keypair, kp;
        return _regenerator["default"].wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                _context26.next = 2;
                return _libsodiumWrappers["default"].ready;

              case 2:
                keypair = _libsodiumWrappers["default"].crypto_box_keypair();
                _context26.t0 = _e3dbClientInterface.types.KeyPair;
                _context26.next = 6;
                return this.b64encode(keypair.publicKey);

              case 6:
                _context26.t1 = _context26.sent;
                _context26.next = 9;
                return this.b64encode(keypair.privateKey);

              case 9:
                _context26.t2 = _context26.sent;
                kp = new _context26.t0(_context26.t1, _context26.t2);
                return _context26.abrupt("return", kp);

              case 12:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function generateKeypair() {
        return _generateKeypair.apply(this, arguments);
      }

      return generateKeypair;
    }()
    /**
     * Dynamically generate an Ed25519 keypair for use with registration and signing operations
     *
     * @returns {KeyPair} Base64URL-encoded representation of the new keypair
     */

  }, {
    key: "generateSigningKeypair",
    value: function () {
      var _generateSigningKeypair = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee27() {
        var keypair;
        return _regenerator["default"].wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                _context27.next = 2;
                return _libsodiumWrappers["default"].ready;

              case 2:
                keypair = _libsodiumWrappers["default"].crypto_sign_keypair();
                _context27.t0 = _e3dbClientInterface.types.KeyPair;
                _context27.next = 6;
                return this.b64encode(keypair.publicKey);

              case 6:
                _context27.t1 = _context27.sent;
                _context27.next = 9;
                return this.b64encode(keypair.privateKey);

              case 9:
                _context27.t2 = _context27.sent;
                return _context27.abrupt("return", new _context27.t0(_context27.t1, _context27.t2));

              case 11:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));

      function generateSigningKeypair() {
        return _generateSigningKeypair.apply(this, arguments);
      }

      return generateSigningKeypair;
    }()
  }, {
    key: "str2ab",
    value: function str2ab(str) {
      var buf = new ArrayBuffer(str.length);
      var bufView = new Uint8Array(buf);

      for (var i = 0, strLen = str.length; i < strLen; i++) {
        bufView[i] = str.charCodeAt(i);
      }

      return buf;
    }
  }, {
    key: "encryptLargeFile",
    value: function () {
      var _encryptLargeFile = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee28(fileName, ak) {
        var msg, nonces, names, title, encryptedFileName, TAG_FINAL, TAG_MESSAGE, dk, edkN, edk, header1, header2, header3, header, headerAB, headerUint8, outstream, writer, encryptedLength, hash, res, state, sodiumHeader, instream, reader, chunk, encryptedFileBlock, _encryptedFileBlock, checkSum;

        return _regenerator["default"].wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                _context28.next = 2;
                return _libsodiumWrappers["default"].ready;

              case 2:
                if (_fs["default"].existsSync(fileName)) {
                  _context28.next = 5;
                  break;
                }

                msg = "ERROR: file '" + fileName + "' does not exist.";
                throw msg;

              case 5:
                nonces = fileName.split('.');
                names = nonces[0].split('/');
                title = names[names.length - 1];
                encryptedFileName = "e2e-".concat(title, ".bin");

                _fs["default"].open(encryptedFileName, 'w', function (err) {
                  if (err) {
                    var _msg = 'ERROR: cannot create new file.';
                    throw _msg;
                  }
                });

                TAG_FINAL = _libsodiumWrappers["default"].crypto_secretstream_xchacha20poly1305_TAG_FINAL;
                TAG_MESSAGE = _libsodiumWrappers["default"].crypto_secretstream_xchacha20poly1305_TAG_MESSAGE;
                _context28.next = 14;
                return this.randomKey();

              case 14:
                dk = _context28.sent;
                _context28.next = 17;
                return this.randomNonce();

              case 17:
                edkN = _context28.sent;
                edk = _libsodiumWrappers["default"].crypto_secretbox_easy(dk, edkN, ak);
                header1 = _constants.FILE_VERSION;
                _context28.next = 22;
                return this.b64encode(edk);

              case 22:
                header2 = _context28.sent;
                _context28.next = 25;
                return this.b64encode(edkN);

              case 25:
                header3 = _context28.sent;
                header = "".concat(header1, ".").concat(header2, ".").concat(header3, ".");
                headerAB = this.str2ab(header);
                headerUint8 = new Uint8Array(headerAB);
                outstream = _fs["default"].createWriteStream(encryptedFileName);
                writer = _awaitifyStream["default"].createWriter(outstream);
                encryptedLength = 0;
                hash = _jsMd["default"].create();
                _context28.next = 35;
                return writer.writeAsync(header);

              case 35:
                hash.update(headerUint8);
                encryptedLength += headerUint8.length;
                res = _libsodiumWrappers["default"].crypto_secretstream_xchacha20poly1305_init_push(dk);
                state = res.state;
                sodiumHeader = res.header;
                hash.update(sodiumHeader);
                _context28.next = 43;
                return writer.writeAsync(sodiumHeader);

              case 43:
                encryptedLength += sodiumHeader.length;
                instream = _fs["default"].createReadStream(fileName);
                reader = _awaitifyStream["default"].createReader(instream);
                chunk = 0;

              case 47:
                _context28.next = 49;
                return reader.readAsync(_constants.FILE_BLOCK_SIZE);

              case 49:
                _context28.t0 = chunk = _context28.sent;

                if (!(_context28.t0 !== null)) {
                  _context28.next = 67;
                  break;
                }

                if (!(chunk !== null && chunk.length === _constants.FILE_BLOCK_SIZE)) {
                  _context28.next = 59;
                  break;
                }

                encryptedFileBlock = _libsodiumWrappers["default"].crypto_secretstream_xchacha20poly1305_push(state, chunk, null, TAG_MESSAGE);
                hash.update(encryptedFileBlock);
                _context28.next = 56;
                return writer.writeAsync(encryptedFileBlock);

              case 56:
                encryptedLength += encryptedFileBlock.length;
                _context28.next = 65;
                break;

              case 59:
                if (!(chunk !== null)) {
                  _context28.next = 65;
                  break;
                }

                _encryptedFileBlock = _libsodiumWrappers["default"].crypto_secretstream_xchacha20poly1305_push(state, chunk, null, TAG_FINAL);
                hash.update(_encryptedFileBlock);
                _context28.next = 64;
                return writer.writeAsync(_encryptedFileBlock);

              case 64:
                encryptedLength += _encryptedFileBlock.length;

              case 65:
                _context28.next = 47;
                break;

              case 67:
                checkSum = hash.base64('');
                return _context28.abrupt("return", [encryptedFileName, checkSum, encryptedLength]);

              case 69:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));

      function encryptLargeFile(_x43, _x44) {
        return _encryptLargeFile.apply(this, arguments);
      }

      return encryptLargeFile;
    }()
  }, {
    key: "decryptFile",
    value: function () {
      var _decryptFile = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee29(destFileName, ak, sourceFileName) {
        var instreamHeader, reader, chunk, separated, fileVersion, fileEdk, fileEdkN, msg, headerLength, extraLength, libsodiumHeader, totalHeaderLength, dk, stateIn, ABYTES, chunkBody, instreamBody, readBody, outstream, decryptedChunk;
        return _regenerator["default"].wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                _context29.next = 2;
                return _libsodiumWrappers["default"].ready;

              case 2:
                instreamHeader = _fs["default"].createReadStream(sourceFileName);
                reader = _awaitifyStream["default"].createReader(instreamHeader);
                _context29.next = 6;
                return reader.readAsync();

              case 6:
                chunk = _context29.sent;
                separated = chunk.toString().split('.');
                fileVersion = 3;
                _context29.next = 11;
                return this.b64decode(separated[1]);

              case 11:
                fileEdk = _context29.sent;
                _context29.next = 14;
                return this.b64decode(separated[2]);

              case 14:
                fileEdkN = _context29.sent;

                if (!(parseInt(fileVersion, 10) !== _constants.FILE_VERSION)) {
                  _context29.next = 18;
                  break;
                }

                msg = "File version: ".concat(fileVersion, " does not match supported version: ").concat(_constants.FILE_VERSION);
                throw msg;

              case 18:
                headerLength = separated[0].length + separated[1].length + separated[2].length + 3;
                extraLength = _libsodiumWrappers["default"].crypto_secretstream_xchacha20poly1305_HEADERBYTES;
                libsodiumHeader = chunk.slice(headerLength, headerLength + extraLength);
                totalHeaderLength = headerLength + libsodiumHeader.length;
                instreamHeader.destroy();
                dk = _libsodiumWrappers["default"].crypto_secretbox_open_easy(fileEdk, fileEdkN, ak);
                stateIn = _libsodiumWrappers["default"].crypto_secretstream_xchacha20poly1305_init_pull(libsodiumHeader, dk);
                ABYTES = _libsodiumWrappers["default"].crypto_secretstream_xchacha20poly1305_ABYTES;
                chunkBody = 0;
                instreamBody = _fs["default"].createReadStream(sourceFileName, {
                  start: totalHeaderLength
                });
                readBody = _awaitifyStream["default"].createReader(instreamBody);
                outstream = _fs["default"].createWriteStream(destFileName);

              case 30:
                _context29.next = 32;
                return readBody.readAsync(_constants.FILE_BLOCK_SIZE + ABYTES);

              case 32:
                _context29.t0 = chunkBody = _context29.sent;

                if (!(_context29.t0 !== null)) {
                  _context29.next = 42;
                  break;
                }

                if (!(chunkBody !== null)) {
                  _context29.next = 40;
                  break;
                }

                _context29.next = 37;
                return _libsodiumWrappers["default"].crypto_secretstream_xchacha20poly1305_pull(stateIn, chunkBody);

              case 37:
                decryptedChunk = _context29.sent;
                _context29.next = 40;
                return outstream.write(decryptedChunk.message);

              case 40:
                _context29.next = 30;
                break;

              case 42:
                return _context29.abrupt("return", destFileName);

              case 43:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this);
      }));

      function decryptFile(_x45, _x46, _x47) {
        return _decryptFile.apply(this, arguments);
      }

      return decryptFile;
    }()
  }, {
    key: "encryptNote",
    value: function () {
      var _encryptNote = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee30(note, accessKey) {
        var encryptedNote, encryptedData, key;
        return _regenerator["default"].wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                _context30.next = 2;
                return _libsodiumWrappers["default"].ready;

              case 2:
                encryptedNote = _e3dbClientInterface.types.Note.clone(note);
                encryptedData = {};
                _context30.t0 = _regenerator["default"].keys(note.data);

              case 5:
                if ((_context30.t1 = _context30.t0()).done) {
                  _context30.next = 13;
                  break;
                }

                key = _context30.t1.value;

                if (!note.data.hasOwnProperty(key)) {
                  _context30.next = 11;
                  break;
                }

                _context30.next = 10;
                return this.encryptField(note.data[key], accessKey);

              case 10:
                encryptedData[key] = _context30.sent;

              case 11:
                _context30.next = 5;
                break;

              case 13:
                encryptedNote.data = encryptedData;
                return _context30.abrupt("return", encryptedNote);

              case 15:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30, this);
      }));

      function encryptNote(_x48, _x49) {
        return _encryptNote.apply(this, arguments);
      }

      return encryptNote;
    }()
  }, {
    key: "decryptNote",
    value: function () {
      var _decryptNote = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee31(encrypted, accessKey) {
        var decrypted, decryptedData, key;
        return _regenerator["default"].wrap(function _callee31$(_context31) {
          while (1) {
            switch (_context31.prev = _context31.next) {
              case 0:
                _context31.next = 2;
                return _libsodiumWrappers["default"].ready;

              case 2:
                decrypted = _e3dbClientInterface.types.Note.clone(encrypted);
                decryptedData = {};
                _context31.t0 = _regenerator["default"].keys(encrypted.data);

              case 5:
                if ((_context31.t1 = _context31.t0()).done) {
                  _context31.next = 13;
                  break;
                }

                key = _context31.t1.value;

                if (!encrypted.data.hasOwnProperty(key)) {
                  _context31.next = 11;
                  break;
                }

                _context31.next = 10;
                return this.decryptField(encrypted.data[key], accessKey);

              case 10:
                decryptedData[key] = _context31.sent;

              case 11:
                _context31.next = 5;
                break;

              case 13:
                decrypted.data = decryptedData;
                return _context31.abrupt("return", decrypted);

              case 15:
              case "end":
                return _context31.stop();
            }
          }
        }, _callee31, this);
      }));

      function decryptNote(_x50, _x51) {
        return _decryptNote.apply(this, arguments);
      }

      return decryptNote;
    }()
    /**
     * Function for tsv1 which wraps sodium's crypto_generichash function, uses BLAKE2b. https://libsodium.gitbook.io/doc/hashing/generic_hashing
     *
     * @returns {string} base64 encoded genericHash
     */

  }, {
    key: "genericHash",
    value: function () {
      var _genericHash = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee32(message) {
        var genericHash;
        return _regenerator["default"].wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                _context32.next = 2;
                return _libsodiumWrappers["default"].ready;

              case 2:
                genericHash = _libsodiumWrappers["default"].crypto_generichash(_libsodiumWrappers["default"].crypto_generichash_BYTES, message);
                return _context32.abrupt("return", this.b64encode(genericHash));

              case 4:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32, this);
      }));

      function genericHash(_x52) {
        return _genericHash.apply(this, arguments);
      }

      return genericHash;
    }()
    /**
     * Function for tsv1 which wraps sodium's crypto_sign_detached function, https://libsodium.gitbook.io/doc/public-key_cryptography/public-key_signatures.
     * Creates signature without attaching a copy of the original message.
     *
     * @returns {string} base64 encoded signature
     */

  }, {
    key: "signDetached",
    value: function () {
      var _signDetached = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee33(stringToSign, privateKey) {
        var rawKey, rawString, signature;
        return _regenerator["default"].wrap(function _callee33$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                _context33.next = 2;
                return _libsodiumWrappers["default"].ready;

              case 2:
                _context33.next = 4;
                return this.b64decode(privateKey);

              case 4:
                rawKey = _context33.sent;
                _context33.next = 7;
                return this.b64decode(stringToSign);

              case 7:
                rawString = _context33.sent;
                signature = _libsodiumWrappers["default"].crypto_sign_detached(rawString, rawKey);
                return _context33.abrupt("return", this.b64encode(signature));

              case 10:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee33, this);
      }));

      function signDetached(_x53, _x54) {
        return _signDetached.apply(this, arguments);
      }

      return signDetached;
    }()
  }]);
  return Crypto;
}(_e3dbClientInterface.Crypto);

exports["default"] = Crypto;